<!DOCTYPE html>
<html lang="en">
	<head>
    <link href="https://fonts.googleapis.com/css2?family=Six+Caps&display=swap" rel="stylesheet">
		<meta charset="utf-8">
		<title>Portfolio Vale Alvarez</title>
		<link rel="stylesheet" href="Public/index.css">
    <link rel="preload" href="Images/CocinaDiaVideo.mp4" as="video" type="video/mp4">
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@v0.163.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@v0.163.0/examples/jsm/"
        }
      }
    </script>
    <style>
      /* Estilos mejorados para el botón de cerrar - MÁS GRANDE Y VISIBLE */
      #rotateMessage {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.85);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 9999;
        font-family: Arial, sans-serif;
      }
      
      #rotateMessage .message-box {
        background: white;
        padding: 40px;
        border-radius: 15px;
        text-align: center;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        position: relative;
      }
      
      #rotateMessage .close-btn {
        position: absolute;
        top: 15px;
        right: 15px;
        background: #ff4757;
        color: white;
        border: none;
        border-radius: 50%;
        width: 50px;  /* Más grande */
        height: 50px; /* Más grande */
        cursor: pointer;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 24px; /* Texto más grande */
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.3s ease;
        z-index: 10000;
      }
      
      #rotateMessage .close-btn:hover {
        background: #ff6b81;
        transform: scale(1.1);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }
      
      #rotateMessage .close-btn:active {
        transform: scale(0.95);
      }
      
      #rotateMessage .phone-icon {
        display: flex;
        justify-content: center;
        margin-bottom: 25px;
        position: relative;
        height: 100px;
      }
      
      #rotateMessage .phone {
        width: 60px;
        height: 100px;
        border: 4px solid #333;
        border-radius: 12px;
        position: relative;
      }
      
      #rotateMessage .screen {
        width: 40px;
        height: 40px;
        border: 3px solid #333;
        border-radius: 5px;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) rotate(0deg);
        animation: rotateAnimation 3s infinite ease-in-out;
      }
      
      @keyframes rotateAnimation {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        50% { transform: translate(-50%, -50%) rotate(90deg); }
      }
      
      #rotateMessage p {
        font-size: 18px;
        line-height: 1.5;
        color: #333;
        margin: 0;
      }
    </style>
	</head>
    <body id="top">
      <!-- Overlay aviso orientación -->
      <div id="rotateMessage">
        <button class="close-btn" title="Cerrar">X</button>
        <div class="message-box">
          <div class="phone-icon">
            <div class="phone"></div>
            <div class="screen"></div>
          </div>
          <p>For a better experience, rotate your device or zoom out the page (Ctrl -).</p>
        </div>
      </div>
       <div id="page-wrapper">
      <!-- Pantalla de carga -->
       <div id="preloader">
        <div class="loader"> </div>
        <div id="progress-text">Loading Portfolio... 0%</div>
      </div>
      <div class="Fondo-Inicio">
        <video id="themeVideo" autoplay loop muted playsinline>
          <source src="Images/CocinaNocheVideo.mp4" type="video/mp4">
          <!-- Fallback: imagen si no soporta video -->
          <img src="Images/imagennoche.png" alt="Noche de fondo">
        </video>
        <img src="Images/3dartist.png" class="threedartist">
        <img src="Images/PortfoliTitle.png" class="Titul">
        <img src="Images/OTitle.png" class="Titulo">
        <img src="Images/Sol.png" class = LunaSol id="themeToggle">
        <div class="About-Me">
          <img src="Images/1.jpg" class="SobremiText">
          <div class="contenedor-blender">
            <img src="Images/BlenderLogo.png" class="Blender">
            <img src="Images/CuatroEstrellas.png" class="estrellas-Blender">
            <img src="Images/habilidadesBlender.png" class="habilidades-Blender">
          </div>
          <div class="contenedor-substance">
            <img src="Images/Substance.png" class="Substance">
            <img src="Images/CuatroEstrellas.png" class="estrellas-Substance">
            <img src="Images/habilidadesSubstance.png" class="habilidades-Substance">
          </div>
          <div class="contenedor-Clip">
            <img src="Images/Clip.png" class="Clip">
            <img src="Images/CuatroEstrellas.png" class="estrellas-Clip">
            <img src="Images/habilidadesClip.png" class="habilidades-Clip">
          </div>
          <img src="Images/2.jpg" class="Echoes1">
          <img src="Images/3.jpg" class="EchoesTitle">
          <div class="video-container-echoes">
            <iframe 
              src="https://www.youtube.com/embed/_k2y8_AW4do" 
              title="YouTube video"
              frameborder="0" 
              allow="encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen>
            </iframe>
          </div>
          <video class="mi-video" autoplay loop muted playsinline>
            <source src="Cabrera.webm" type="video/webm">
            Tu navegador no soporta video transparente.
          </video>
          <video class="mi-videochime" autoplay loop muted playsinline>
            <source src="SillaVale.webm" type="video/webm">
            Tu navegador no soporta video transparente.
          </video>
          <img src="Images/4.jpg" class="Echoes2">
          <img src="Images/5.jpg" class="Echoes3">
          <img src="Images/6.jpg" class="Echoes4">

          <img src="Images/7.jpg" class="Nox1">
          <img src="Images/8.jpg" class="Nox2">
          <div class="video-container">
            <iframe 
              src="https://www.youtube.com/embed/rsPubY8bLgo" 
              title="YouTube video"
              frameborder="0" 
              allow="encrypted-media; gyroscope; picture-in-picture"
              allowfullscreen>
            </iframe>
          </div>
  </div>

    <footer class="site-footer">
      <a href="#top" class="footer-btn footer-name" title="Go up">
        Valeria Alvarez
      </a>
      <a href="mailto:valalvarios@gmail.com" class="footer-btn" title="Contact me">
        <i class="fas fa-envelope"></i>
      </a>
      <a href="Docs/CV_VALERIA ALVAREZ RIOS.pdf" class="footer-btn" title="Download my CV" download>
        <i class="fas fa-file-alt"></i>
      </a>
    </footer>

      <!-- Cargar Font Awesome para íconos -->
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

     <script>
      // Script mejorado para el comportamiento del footer
      document.addEventListener("DOMContentLoaded", () => {
        const footer = document.querySelector(".site-footer");
        if (!footer) return;

        const nearBottomThreshold = 200; 
        const minScrolledToTriggerOnUp = 100; 
        let lastScroll = window.pageYOffset || 0;
        let footerTimeout = null;

        function handleScroll() {
          const currentScroll = window.pageYOffset || 0;
          const scrolledDownEnough = currentScroll > minScrolledToTriggerOnUp;
          const nearBottom = (currentScroll + window.innerHeight) >= (document.documentElement.scrollHeight - nearBottomThreshold);

          // Limpiar timeout anterior si existe
          if (footerTimeout) {
            clearTimeout(footerTimeout);
          }
          
          if (nearBottom) {
            footer.classList.add("visible");
          }
          else if (currentScroll < lastScroll && scrolledDownEnough) {
            footer.classList.add("visible");
            // Ocultar después de 3 segundos si no hay más interacción
            footerTimeout = setTimeout(() => {
              if (!nearBottom) footer.classList.remove("visible");
            }, 3000);
          } else {
            footer.classList.remove("visible");
          }

          lastScroll = currentScroll;
        }

        // Mostrar footer al hacer hover
        footer.addEventListener("mouseenter", () => {
          if (footerTimeout) clearTimeout(footerTimeout);
          footer.classList.add("visible");
        });

        // Ocultar después de salir del footer (con retraso)
        footer.addEventListener("mouseleave", () => {
          const currentScroll = window.pageYOffset || 0;
          const nearBottom = (currentScroll + window.innerHeight) >= (document.documentElement.scrollHeight - nearBottomThreshold);
          
          if (!nearBottom) {
            footerTimeout = setTimeout(() => {
              footer.classList.remove("visible");
            }, 1000);
          }
        });

        window.addEventListener("scroll", handleScroll, { passive: true });
        handleScroll();
      });
      </script>

      <script>
        // Script mejorado para cambiar entre temas
        const toggleBtn = document.getElementById("themeToggle");
        const themeImage = document.getElementById("themeVideo");

        // Precargar ambos videos para transiciones suaves
        const dayVideo = new Video();
        dayVideo.src = "Images/CocinaDiaVideo.mp4";
        dayVideo.preload = "auto";
        
        const nightVideo = new Video();
        nightVideo.src = "Images/CocinaNocheVideo.mp4";
        nightVideo.preload = "auto";

        function cambiarVideoSuave(videoElement, newSrc, duracion = 500) {
          return new Promise((resolve) => {
            const tiempoActual = videoElement.currentTime;
            videoElement.style.transition = `opacity ${duracion}ms ease-in-out`;
            videoElement.style.opacity = 0;

            setTimeout(() => {
              videoElement.querySelector("source").src = newSrc;
              videoElement.load();

              videoElement.onloadeddata = () => {
                const nuevoTiempo = Math.min(tiempoActual, videoElement.duration || tiempoActual);
                videoElement.currentTime = nuevoTiempo;
                videoElement.play();
                videoElement.style.opacity = 1;
                resolve();
              };
              
              videoElement.onerror = () => {
                videoElement.style.opacity = 1;
                resolve();
              };
            }, duracion);
          });
        }

        let darkMode = false;

        toggleBtn.addEventListener("click", async () => {
          // Deshabilitar múltiples clics durante la transición
          toggleBtn.style.pointerEvents = "none";
          
          darkMode = !darkMode;

          if (darkMode) {
            toggleBtn.src = "Images/Luna.png";
            await cambiarVideoSuave(themeVideo, "Images/CocinaDiaVideo.mp4");
          } else {
            toggleBtn.src = "Images/Sol.png";
            await cambiarVideoSuave(themeVideo, "Images/CocinaNocheVideo.mp4");
          }
          
          // Rehabilitar clics después de la transición
          setTimeout(() => {
            toggleBtn.style.pointerEvents = "auto";
          }, 500);
        });
      </script>

     <script>
      // Script mejorado para carga progresiva de recursos con simulación
      function waitForVideo(videoElement) {
        return new Promise(resolve => {
          if (videoElement.readyState >= 3) {
            resolve();
          } else {
            videoElement.addEventListener("canplaythrough", resolve, { once: true });
            videoElement.addEventListener("error", resolve); // Manejar errores
          }
        });
      }

      function waitForImage(src) {
        return new Promise(resolve => {
          const img = new Image();
          img.onload = () => resolve({success: true, src});
          img.onerror = () => resolve({success: false, src});
          img.src = src;
        });
      }

      // Función para cargar recursos en lotes con delay
      function loadInBatches(items, batchSize, delay) {
        const results = [];
        let index = 0;
        
        return new Promise(async (resolve) => {
          while (index < items.length) {
            const batch = items.slice(index, index + batchSize);
            index += batchSize;
            
            const batchPromises = batch.map(item => waitForImage(item));
            const batchResults = await Promise.all(batchPromises);
            results.push(...batchResults);
            
            // Esperar antes del siguiente lote
            if (index < items.length) {
              await new Promise(r => setTimeout(r, delay));
            }
          }
          resolve(results);
        });
      }

      // Variables globales para controlar la carga
      let loadingComplete = false;
      let forcedClose = false;
      let progressInterval;
      let simulatedProgress = 0;

      async function preloadResources() {
        const videoNoche = document.getElementById("themeVideo");
        const videoDia = document.createElement("video");
        videoDia.src = "Images/CocinaDiaVideo.mp4";
        videoDia.preload = "auto";

        // Lista de todas las imágenes
        const images = [
          "Images/imagennoche.png",
          "Images/3dartist.png",
          "Images/PortfoliTitle.png",
          "Images/OTitle.png",
          "Images/Sol.png",
          "Images/Luna.png",
          "Images/BlenderLogo.png",
          "Images/CuatroEstrellas.png",
          "Images/habilidadesBlender.png",
          "Images/Substance.png",
          "Images/habilidadesSubstance.png",
          "Images/Clip.png",
          "Images/habilidadesClip.png",
          "Images/1.jpg",
          "Images/2.jpg",
          "Images/3.jpg",
          "Images/4.jpg",
          "Images/5.jpg",
          "Images/6.jpg",
          "Images/7.jpg",
          "Images/8.jpg"
        ];

        // Iniciar progreso simulado
        startSimulatedProgress();
        
        // Primero cargar videos
        const videoPromises = [
          waitForVideo(videoNoche),
          waitForVideo(videoDia)
        ];

        let loaded = 0;
        const total = images.length + videoPromises.length;
        const progressText = document.getElementById("progress-text");

        // Actualizar progreso para videos
        const trackedVideoPromises = videoPromises.map(promise =>
          promise.then(() => {
            loaded++;
            const percent = Math.round((loaded / total) * 100);
            // Usar el mayor valor entre simulado y real
            const displayPercent = Math.max(simulatedProgress, percent);
            progressText.textContent = `Loading Portfolio... ${displayPercent}%`;
          })
        );

        await Promise.all(trackedVideoPromises);

        // Luego cargar imágenes en lotes de 3 con delay de 100ms
        await loadInBatches(images, 3, 100).then(imageResults => {
          imageResults.forEach((result, index) => {
            loaded++;
            const percent = Math.round((loaded / total) * 100);
            // Usar el mayor valor entre simulado y real
            const displayPercent = Math.max(simulatedProgress, percent);
            progressText.textContent = `Loading Portfolio... ${displayPercent}%`;
            
            // Opcional: registrar imágenes que no cargaron
            if (!result.success) {
              console.warn(`Failed to load: ${result.src}`);
            }
          });
        });
        
        // Marcar que la carga está completa
        loadingComplete = true;
        clearInterval(progressInterval);
      }

      // Función para simular progreso de carga
      function startSimulatedProgress() {
        simulatedProgress = 0;
        const progressText = document.getElementById("progress-text");
        
        progressInterval = setInterval(() => {
          if (simulatedProgress < 100) {
            simulatedProgress += 1;
            // Actualizar solo si es mayor que el progreso real
            const currentText = progressText.textContent;
            const currentPercent = parseInt(currentText.match(/\d+/)) || 0;
            
            if (simulatedProgress > currentPercent) {
              progressText.textContent = `Loading Portfolio... ${simulatedProgress}%`;
            }
          }
        }, 100); // Aumenta 1% cada 100ms
      }

      // Función para cerrar el preloader
      function hidePreloader() {
        const preloader = document.getElementById("preloader");
        if (preloader) {
          preloader.classList.add("hidden");
          clearInterval(progressInterval);
        }
      }

      window.addEventListener("load", async () => {
        const preloader = document.getElementById("preloader");
        
        // Configurar timeout para forzar cierre después de 12 segundos
        const forceCloseTimeout = setTimeout(() => {
          if (!loadingComplete && !forcedClose) {
            forcedClose = true;
            hidePreloader();
          }
        }, 8000); 
        
        // Configurar progreso simulado para llegar a 50% en 10 segundos
        setTimeout(() => {
          if (!loadingComplete && simulatedProgress < 70) {
            simulatedProgress = 80;
            const progressText = document.getElementById("progress-text");
            const currentText = progressText.textContent;
            const currentPercent = parseInt(currentText.match(/\d+/)) || 0;
            
            if (simulatedProgress > currentPercent) {
              progressText.textContent = `Loading Portfolio... ${simulatedProgress}%`;
            }
          }
        }, 2000); // 10 segundos
        
        try {
          await preloadResources();
          hidePreloader();
          clearTimeout(forceCloseTimeout);
        } catch (error) {
          console.error("Error during preloading:", error);
          // Ocultar preloader incluso si hay errores
          hidePreloader();
          clearTimeout(forceCloseTimeout);
        }
      });
     </script>

      <script>
        // Script mejorado para detección de orientación en todos los dispositivos
        function checkScreenSize() {
          const rotateMessage = document.getElementById("rotateMessage");
          const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
          const isApple = /iPhone|iPad|iPod|Macintosh/i.test(navigator.userAgent);
          
          // Si el usuario ya cerró el mensaje manualmente, no mostrarlo
          if (localStorage.getItem('rotateMessageClosed') === 'true') {
            rotateMessage.style.display = "none";
            return;
          }
          
          if (isMobile) {
            // Para dispositivos móviles, verificar orientación
            const isPortrait = window.innerHeight > window.innerWidth;
            
            if (isPortrait) {
              rotateMessage.style.display = "flex";
            } else {
              rotateMessage.style.display = "none";
            }
          } else if (isApple) {
            // Para dispositivos Apple no móviles, verificar ancho de pantalla
            if (window.innerWidth < 1200) {
              rotateMessage.style.display = "flex";
            } else {
              rotateMessage.style.display = "none";
            }
          } else {
            // Para otros dispositivos
            if (window.innerWidth < 1820) {
              rotateMessage.style.display = "flex";
            } else {
              rotateMessage.style.display = "none";
            }
          }
        }

        // Configurar el botón de cerrar para el mensaje de rotación
        document.querySelector('#rotateMessage .close-btn').addEventListener('click', function() {
          const rotateMessage = document.getElementById("rotateMessage");
          rotateMessage.style.display = "none";
          // Guardar preferencia para no mostrar nuevamente
          localStorage.setItem('rotateMessageClosed', 'true');
        });

        // Detectar cambios de orientación en dispositivos móviles
        function setupOrientationDetection() {
          // Verificar inicialmente
          checkScreenSize();
          
          // Para dispositivos que soportan orientationchange
          if (typeof window.orientation !== 'undefined') {
            window.addEventListener('orientationchange', checkScreenSize);
          }
          
          // Para todos los dispositivos
          window.addEventListener('resize', checkScreenSize);
        }

        window.addEventListener("load", setupOrientationDetection);
        window.addEventListener("resize", checkScreenSize);
      </script>

      <script type="module" src="./main.js"></script>
      <script src="golpe.js"></script>
    </body>
</html>